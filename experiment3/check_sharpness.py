#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse, ast
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# ===== colors =====
PALETTE = {
    "poe": "skyblue",
    "moe": "lightgreen",
    "mopoe": "plum",
    "emp_t1": "salmon",
    "sampler": "gray",
    "evaluator": "black",
}

COLOR_MAP = {
    "SI_emp":   PALETTE["emp_t1"],
    "SI_poe":   PALETTE["poe"],
    "SI_moe":   PALETTE["moe"],
    "SI_mopoe": PALETTE["mopoe"],
    "Cum_emp":   PALETTE["emp_t1"],
    "Cum_poe":   PALETTE["poe"],
    "Cum_moe":   PALETTE["moe"],
    "Cum_mopoe": PALETTE["mopoe"],
}

# ---------- helpers ----------
def H_of(arr):
    """Shannon entropy (nats). arr can be list-like; auto-normalized & epsilon-safe."""
    p = np.array(arr, dtype=float)
    z = p.sum()
    if not np.isfinite(z) or z <= 0:
        return np.nan
    p = p / z
    p = np.clip(p, 1e-12, None)
    return float(-(p * np.log(p)).sum())

def parse_list(x):
    """Parse list-like field that may be stringified list or None."""
    if x is None or (isinstance(x, float) and np.isnan(x)):
        return None
    if isinstance(x, (list, tuple, np.ndarray)):
        return x
    if isinstance(x, str):
        s = x.strip()
        if s in ("", "None", "null", "NaN"):
            return None
        try:
            return ast.literal_eval(s)
        except Exception:
            return None
    return None

def add_entropy_cols(df, col_map):
    for out_col, src_col in col_map.items():
        if src_col in df.columns:
            def _to_H(v):
                v2 = parse_list(v)
                return np.nan if v2 is None else H_of(v2)
            df[out_col] = df[src_col].apply(_to_H)
        else:
            df[out_col] = np.nan
    return df

def backward_SI_by_trial(df, H_col, out_SI_col):
    if H_col not in df.columns:
        df[out_SI_col] = np.nan
        return df
    df[out_SI_col] = (
        df.groupby("trial", sort=False)[H_col]
          .apply(lambda s: s.shift(1) - s)
          .values
    )
    return df

def round_summary(df, cols):
    return (df.groupby("round", as_index=True)[cols]
              .agg(["mean", "std", "count"])
              .sort_index())

def _apply_round_xticks(ax, rounds):
    ax.set_xticks(np.arange(int(np.min(rounds)), int(np.max(rounds)) + 1, 1))

def plot_mean_ci(by_round, series, title, ylabel, out_png, labels_override=None):
    rounds = by_round.index.values
    fig, ax = plt.subplots(figsize=(16, 6.2))
    labels = {
        "SI_emp":"SI_emp", "SI_poe":"SI_poe", "SI_moe":"SI_moe", "SI_mopoe":"SI_mopoe",
        "Cum_emp":"Empirical", "Cum_poe":"PoE", "Cum_moe":"MoE", "Cum_mopoe":"MoPoE (α=0.5)"
    }
    if labels_override:
        labels.update(labels_override)
    for col in series:
        if col not in by_round.columns.get_level_values(0):
            continue
        m = by_round[(col, "mean")].astype(float).values
        s = by_round[(col, "std")].astype(float).values
        n = by_round[(col, "count")].astype(float).values
        with np.errstate(invalid="ignore", divide="ignore"):
            sem = s / np.sqrt(np.maximum(n, 1))
            ci = 1.96 * sem
        color = COLOR_MAP.get(col, None)
        ax.plot(rounds, m, linewidth=3, label=labels.get(col, col), color=color)
        ax.fill_between(rounds, m - ci, m + ci, alpha=0.15, color=color)
    ax.set_xlabel("Round", fontsize=26)
    ax.set_xlim(1, 10)
    ax.set_ylabel(ylabel, fontsize=26)
    if "Cumulative" in ylabel:
        ax.set_ylim(0, 1.4)                        
    _apply_round_xticks(ax, rounds)
    ax.tick_params(axis="both", which="major", labelsize=22) 
    ax.tick_params(axis="both", which="minor", labelsize=22) 

    ax.grid(alpha=0.25)
    ax.legend(loc="best", fontsize=25)
    plt.tight_layout()
    plt.savefig(out_png, dpi=180)
    plt.close(fig)

def main():
    ap = argparse.ArgumentParser(description="Compute entropy, SI, and cumulative sharpening by round (Emp vs Models).")
    ap.add_argument("--csv", default="analysis_out/recursive_metrics.csv",
                    help="Path to metrics CSV generated by poe_moe_analysis.py (recursive mode).")
    ap.add_argument("--save_round_csv", default="si_round_summary.csv",
                    help="Where to save round-level SI summary CSV.")
    ap.add_argument("--save_overall_csv", default="si_overall_summary.csv",
                    help="Where to save overall pooled SI stats CSV.")
    ap.add_argument("--save_cum_round_csv", default="cum_round_summary.csv",
                    help="Where to save round-level cumulative sharpening summary CSV.")
    args = ap.parse_args()

    # Load
    df = pd.read_csv(args.csv)

    # Parse list-like columns safely
    list_cols = [
        "Pt", "Ptp", "PoE3", "MoE_evalprod", "MoPoE",
        "PoE3_raw", "MoE_evalprod_raw", "MoPoE_raw"
    ]
    for c in list_cols:
        if c in df.columns:
            df[c] = df[c].apply(parse_list)

    # --- Entropy columns (Empirical & Models use RAW) ---
    df = add_entropy_cols(df, {
        "H_emp_t":  "Pt",
        "H_emp_t1": "Ptp",
    })
    df = add_entropy_cols(df, {
        "H_poe":   "PoE3_raw",
        "H_moe":   "MoE_evalprod_raw",
        "H_mopoe": "MoPoE_raw",
    })

    # Sort for within-trial diffs
    df = df.sort_values(["trial", "round"]).reset_index(drop=True)

    # ---- Sharpening Index SI = H(r-1) - H(r) ----
    df = backward_SI_by_trial(df, "H_emp_t", "SI_emp")
    df = backward_SI_by_trial(df, "H_poe",   "SI_poe")
    df = backward_SI_by_trial(df, "H_moe",   "SI_moe")
    df = backward_SI_by_trial(df, "H_mopoe", "SI_mopoe")

    si_cols = [c for c in ["SI_emp", "SI_poe", "SI_moe", "SI_mopoe"] if c in df.columns]
    by_round_si = round_summary(df, si_cols)
    print(by_round_si)
    if args.save_round_csv:
        by_round_si.to_csv(args.save_round_csv, index=True)

    # Plot SI (mean ± 95%CI)
    plot_mean_ci(by_round_si, si_cols,
                 "Sharpening by Round (mean ± 95% CI, across trials)",
                 "Sharpening Index  H(r-1) − H(r)  (nats)",
                 "si_by_round.png")

    # ---- CUMULATIVE sharpening: H(1) − H(r) for Emp/PoE/MoE/MoPoE ----
    def _cum(df, Hcol):
        first = (df.sort_values(["trial","round"])
                   .groupby("trial")[Hcol].transform("first"))
        return first - df[Hcol]

    for Hcol, Ccol in [("H_emp_t","Cum_emp"),
                       ("H_poe","Cum_poe"),
                       ("H_moe","Cum_moe"),
                       ("H_mopoe","Cum_mopoe")]:
        if Hcol in df.columns:
            df[Ccol] = _cum(df, Hcol)

    cum_cols = [c for c in ["Cum_emp","Cum_poe","Cum_moe","Cum_mopoe"] if c in df.columns]
    by_round_cum = round_summary(df, cum_cols)
    if args.save_cum_round_csv:
        by_round_cum.to_csv(args.save_cum_round_csv, index=True)

    plot_mean_ci(by_round_cum, cum_cols,
                 "Cumulative Sharpening by Round (Emp vs Models)",
                 "Cumulative sharpening",
                 "cum_sharpening_all.png",
                 labels_override={
                     "Cum_emp":"Empirical", "Cum_poe":"PoE",
                     "Cum_moe":"MoE", "Cum_mopoe":"MoPoE"
                 })

    # ---- Emp vs Models: cumulative gap (positive ⇒ Emp sharper) ----
    rounds = by_round_cum.index.values
    gaps = {}
    if ("Cum_emp","mean") in by_round_cum.columns:
        emp = by_round_cum[("Cum_emp","mean")].values
        for tag in ["poe","moe","mopoe"]:
            key = f"Cum_{tag}"
            if (key,"mean") in by_round_cum.columns:
                gaps[tag] = emp - by_round_cum[(key,"mean")].values

    if gaps:
        fig, ax = plt.subplots(figsize=(16, 6.2))
        for tag, arr in gaps.items():
            ax.plot(rounds, arr, lw=2, label=f"Emp − {tag.upper()}",
                    color=PALETTE.get(tag, None))
        ax.axhline(0, color="k", lw=1, alpha=0.4)
        ax.set_xlabel("Round")
        ax.set_ylabel("Gap in cumulative sharpening (nats)")
        ax.set_title("Does Emp sharpen more than the models?")
        _apply_round_xticks(ax, rounds)   # ← 1刻み
        ax.grid(alpha=0.25)
        ax.legend(loc="best")
        plt.tight_layout()
        plt.savefig("cum_gap_vs_models.png", dpi=180)
        plt.close(fig)

    # ---- Overall pooled stats for SI（NaN は自動除外）----
    overall = df[si_cols].agg(["mean", "std", "count"])
    print("\nOVERALL (pooled across rounds):\n", overall)
    if args.save_overall_csv:
        overall.to_csv(args.save_overall_csv, index=True)

    # ---- Sanity check: H_emp_t1 ≈ forward shift of H_emp_t ----
    if "H_emp_t1" in df.columns:
        shifted = df.groupby("trial", sort=False)["H_emp_t"].shift(-1)
        same = np.allclose(
            df["H_emp_t1"].values,
            shifted.values,
            equal_nan=True,
            atol=1e-8,
            rtol=1e-5,
        )
        print("\n[check] H_emp_t1 equals forward-shift(H_emp_t)? ->", same)

if __name__ == "__main__":
    main()
